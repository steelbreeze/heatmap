<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="description" content="Landscape map viewpoint visualisation generation tool for JavaScript written in TypeScript." />
	<meta name="robots" content="index, follow" />
	<meta property="og:image" content="https://steelbreeze.net/images/landscape-map.png">
	<meta property="og:image:type" content="image/png">
	<title>Landscape map viewpoint</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
	<link rel="stylesheet" href="https://steelbreeze.net/style/steelbreeze.css">
	<link rel="stylesheet" href="./style/landscape.css">
	<link rel="stylesheet" href="./style/controls.css">
</head>

<body>
	<header>
		<div class="fixedWidth">
			<nav>
				<a href="/">
					<h1>steelbreeze</h1>
				</a>
			</nav>
			<nav>
				<a href="../pivot">pivot</a>
				<a href="../landscape" class="selected">landscape</a>
				<a href="../state">state</a>
			</nav>
		</div>
	</header>
	<main>
		<div class="mainSection">
			<div class="fixedWidth">
				<article>
					<h1>Landscape map viewpoint</h1>
					<p>The landscape map viewpoint as a visualisation good for articulating a portfolio using three
						dimensions on the x-axis, y-axis and colour-coding. They can show the health of the portfolio
						clearly: if there is a high concentration of elements within a particular cell, then itâ€™s
						typically a sign that there is redundancy; conversely if an element covers too much of the table
						it could be over-extended. The colour-coding speaks for itself. Knowing your domain, you will
						know shapes and patterns are acceptable or not.</p>
				</article>
				<article class="widget" id="landscapeTarget">
					<table id="tablan" class="landscape"></table>
				</article>
				<article class="widget">
					<table class="timeline">
						<tbody>
							<tr>
								<td colspan="3">
									<label for="xAxisSelector">x axis:</label>
									<select id="xAxisSelector" onchange="createCube()"></select>
								</td>
							</tr>
							<tr>
								<td colspan="3">
									<label for="yAxisSelector">y axis:</label>
									<select id="yAxisSelector" onchange="createCube()"></select>
								</td>
							</tr>
							<tr>
								<td colspan="3">
									<label>Split by axis</label>
									<label for="splitByY">y:</label>
									<input type="radio" name="splitAxis" id="splitByY" onchange="filterCube()" />
									<label for="splitByX">x:</label>
									<input type="radio" name="splitAxis" id="splitByX" onchange="filterCube()"
										checked />
								</td>
							</tr>
							<tr>
								<td colspan="3">
									<label>Merge by axis</label>
									<label for="mergeByY">y:</label>
									<input type="checkbox" id="mergeByY" onchange="renderCube()" checked />
									<label for="mergeByX">x:</label>
									<input type="checkbox" id="mergeByX" onchange="renderCube()" checked />
								</td>
							</tr>
							<tr>
								<td colspan="3">View as of: <span id="dateOfInterest"></span></td>
							</tr>
							<tr>
								<td colspan="3">
									<input type="range" min="-1095" max="1096" value="0" class="slider" id="slider"
										oninput="filterCube()" />
								</td>
							</tr>
							<tr>
								<td id="earliestDate">Earliest</td>
								<td id="todaysDate">Today</td>
								<td id="latestDate">Latest</td>
							</tr>
						</tbody>
					</table>
				</article>
				<article>
					<p>Move the slider above left/right to change the view in time, or change the dimensions used on
						each axis.</p>
					<p>Links: <a href="/landscape">Project</a>; <a
							href="https://github.com/steelbreeze/landscape">GitHub</a>; <a
							href="https://pubs.opengroup.org/architecture/archimate2-doc/chap08.html#_Toc371945248">Archimate</a>.
					</p>
				</article>
			</div>
		</div>
		<div class="mainSection">
			<div class="fixedWidth">
				<article>
					<h1>Notes</h1>
					<p>The application landscape map viewpoint above is auto-generated from a <a
							href="./data/mythicalBank.csv" target="_top">CSV file</a> containing information about
						applications and the context in which they are used. The landscape maps viewpoint conveys a
						great deal of information in a compact form, showing the health of a domain clearly and
						consisely. For more information see the <a
							href="https://pubs.opengroup.org/architecture/archimate2-doc/chap08.html#_Toc371945248"
							target="_blank">Archimate architecture viewpoints</a> documentation. They resemble a pivot
						table, but with content from the underlying data displayed rather than aggregates.</p>
					<p>Two libraries are used: <a href="https://github.com/steelbreeze/pivot">@steelbreeze/pivot</a> and
						<a href="https://github.com/steelbreeze/landscape">@steelbreeze/landscape</a>.
					</p>
					<p>The first is used to pivot the source data into a cube based on the selected x and y axes. The
						axes and cube is the landscape library, but they could equally be used for numerical reporting.
					</p>
					<p>The second is used to render the results. As a cell in a cube may contain multiple values, we
						first create duplicate rows or columns to provide only single values in any table cell, we then
						merge adjacent cells with the same value to provide the resultant table.</p>
				</article>
			</div>
		</div>
		<div class="mainSection">
			<div class="fixedWidth">
				<article>
					<h1>Browser support</h1>
					<p>The layout engine is writtin in TypeScript and transpiled into JavaScript ES6; it should
						therefore work in any modern browser. The json data in this example is loaded with
						<code>window.fetch</code> therefore a polyfil is required for older browsers.
					</p>
				</article>
			</div>
		</div>
		<div class="mainSection">
			<div class="fixedWidth">
				<article>
					<h1>Outstanding work</h1>
					<p>Create a seperate standalone tool to create optimal axes where this is too time consuming to do
						in real time.</p>
					<p>Further optimisations to the axes optimisation algorithm.</p>
					<p>Split cells with multiple application horizontally and vertically for optimal layout.</p>
					<p>Smarter ordering of split cells to expliot affinity with neighbouring cells.</p>
					<p>Base the date slider max and min values based on the underlying data.</p>
				</article>
			</div>
		</div>
	</main>
	<footer>
		<div class="fixedWidth">
			<article>
				<a href="https://www.linkedin.com/in/mesmo/" class="fa fa-linkedin"></a>
				<a href="https://twitter.com/David13276770" class="fa fa-twitter"></a>
			</article>
			<article>
				Copyright &copy; 2020 David Mesquita-Morris.
			</article>
		</div>
	</footer>
	<script crossorigin="anonymous"
		src="https://polyfill.io/v3/polyfill.min.js?features=Promise%2Cfetch%2Cperformance.now"></script>
	<script src="./dist/d3-dsv.min.js"></script>
	<script src="https://steelbreeze.net/pivot/dist/pivot.min.js"></script>
	<script src="./dist/landscape.min.js"></script>
	<script>
		// get DOM elements that are frequently changed
		const dateOfInterest = document.getElementById("dateOfInterest");
		const landscapeTarget = document.getElementById("landscapeTarget");
		const xAxisSelector = document.getElementById("xAxisSelector");
		const yAxisSelector = document.getElementById("yAxisSelector");
		const xAxisOptimised = document.getElementById("xAxisOptimised");
		const yAxisOptimised = document.getElementById("yAxisOptimised");
		const slider = document.getElementById("slider");
		const splitByX = document.getElementById("splitByX");
		const mergeByX = document.getElementById("mergeByX");
		const mergeByY = document.getElementById("mergeByY");

		// define the preferred sequence of each dimension
		const sortOrder = {
			"Capability": ["Market gateway", "Order execution", "Order management", "Lifecycle management", "Confirmations", "Settlement", "Payments"],
			"Product": ["Rates", "FX", "MM", "Credit", "Equities"],
			"Status": ["green", "amber", "red"],
			"Location": ["United States", "United Kingdom", "Germany", "Italy"],
			"Supplier": ["Finastra", "ION", "Kx Systems", "Microsoft", "Murex", "Thunderhead", "Wall Street Systems"],
			"Status": ["green", "amber", "red"]
		};

		// globals that we need to keep track of acros functions
		let data;
		let yAxis;
		let xAxis;
		let cube;
		let filtered;

		// populate the drop-downs for the axes
		Object.keys(sortOrder).forEach(function (axis, index) {
			xAxisSelector.innerHTML += `<option value="${axis}"${axis === "Product" ? " selected" : ""}>${axis}</option>`;
			yAxisSelector.innerHTML += `<option value="${axis}"${axis === "Capability" ? " selected" : ""}>${axis}</option>`;
		});

		// one-off DOM element updates
		document.getElementById("earliestDate").textContent = fromToday(-1095);
		document.getElementById("todaysDate").textContent = fromToday();
		document.getElementById("latestDate").textContent = fromToday(1096);

		// load the applications data
		window.fetch("./data/mythicalBank.csv", { cache: "no-cache" }).then(function (response) { return response.text() }).then(function (csv) {
			// convert the CSV data into a JSON array and save it
			data = d3.csvParse(csv);

			createCube();
		});

		// create the cube on initial load or when an axis changes
		function createCube() {
			//console.time('dimensions');

			// create the dimensions to use as the x and y axes; derive from the source data and sort by a pre-defined sequence
			xAxis = pivot.deriveDimension(data, xAxisSelector.value, { sort: listSort(sortOrder[xAxisSelector.value]) });
			yAxis = pivot.deriveDimension(data, yAxisSelector.value, { sort: listSort(sortOrder[yAxisSelector.value]) });

/*			// create a header dimension
			const xAxisHeader = pivot.dimension([xAxisSelector.value], xAxisSelector.value, () => xAxisSelector.value);
			const yAxisHeader = pivot.dimension([yAxisSelector.value], yAxisSelector.value, () => yAxisSelector.value);

			// join the dimensions with their header dimensions
			xAxis = pivot.join(xAxisHeader, xAxis);
			yAxis = pivot.join(yAxisHeader, yAxis);
*/
			//console.timeEnd('dimensions');
			//console.time('cube');

			// create the cube
			cube = pivot.cube(data, xAxis, yAxis);

			//console.timeEnd('cube');

			filterCube();
		}

		// filter the cube on initial load or when the cube changes then create the raw table
		function filterCube() {
			// get the date of interet from the slider control
			const date = fromToday(slider.value);

			// update the date in the page
			dateOfInterest.textContent = date;

			//console.time('filter');

			// filter the cube using the date of interest
			filtered = pivot.filter(cube, app => (!app.From || app.From < date) && (!app.To || date < app.To));

			//console.timeEnd('filter');

			renderCube();
		}

		// merge adjacent cells based on user
		function renderCube() {
			console.time('split');

			// split the cube and axes along the desired axis, creating a table
			const table = landscape.table(filtered, xAxis, yAxis, key, splitByX.checked); // NOTE: as the merge function modifies the table, this must be done each time

			console.timeEnd('split');
			console.time('merge');

			// merge the split cube along the desired axes
			landscape.merge(table, mergeByX.checked, mergeByY.checked);

			console.timeEnd('merge');

			// render the table in the target element
			renderTable2(table, 'tablan');
		}

		/** Generator to create a sort callback that orders by a preferred list */
		function listSort(list) {
			return (a, b) => list.indexOf(a) - list.indexOf(b);
		}

		function key(app) {
			return { text: app.Name, className: app.Status };
		}

		// helper function to add days to a date
		function fromToday(offset) {
			var result = new Date();

			result.setMilliseconds(result.getMilliseconds() + ((offset || 0) * 86400000));

			return result.toISOString().substr(0, 10);
		}

		// render the table into the DOM
		function renderTable2(table, elementId) {
			//console.time('elements');

			const tableElement = document.createElement('table');
			tableElement.id = elementId;
			tableElement.classList = 'landscape';

			table.forEach((row, rowIndex) => {
				const rowElement = document.createElement('tr');

				for (const cell of row) {
					const cellElement = document.createElement(cell.className.includes('axis') ? 'th' : 'td');
					cellElement.colSpan = cell.colSpan;
					cellElement.rowSpan = cell.rowSpan;
					cellElement.className = `cell ${cell.className}`;

					const divElement = document.createElement('div');
					divElement.appendChild(document.createTextNode(cell.text));

					cellElement.appendChild(divElement);
					rowElement.appendChild(cellElement);
				}

				tableElement.appendChild(rowElement);
			});

			//console.timeEnd('elements');
			//console.time('render');

			document.getElementById(elementId).replaceWith(tableElement);

			//console.timeEnd('render');
		}
	</script>
</body>

</html>